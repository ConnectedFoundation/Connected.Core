using Connected.Storage.Schemas;
using System.Data;
using System.Text;

namespace Connected.Storage.PostgreSql.Schemas;

/// <summary>
/// Base class for PostgreSQL schema synchronization commands.
/// </summary>
/// <remarks>
/// This abstract class provides common functionality for all schema operations including
/// SQL identifier escaping, type formatting, and column definition generation. It ensures
/// consistent PostgreSQL syntax across all schema modification operations and handles
/// PostgreSQL-specific requirements such as double-quote identifier escaping and proper
/// type mappings. The class serves as the foundation for both transaction (write) and
/// query (read) operations against the PostgreSQL schema.
/// </remarks>
internal abstract class SynchronizationCommand
{
	/// <summary>
	/// Escapes a PostgreSQL identifier using double quotes.
	/// </summary>
	/// <param name="identifier">The identifier to escape.</param>
	/// <returns>The escaped identifier in the format "identifier".</returns>
	protected static string Escape(string identifier)
	{
		/*
		 * PostgreSQL uses double quotes for identifier escaping
		 */
		return $"\"{identifier}\"";
	}

	/// <summary>
	/// Escapes a schema-qualified table name for PostgreSQL.
	/// </summary>
	/// <param name="schema">The schema name.</param>
	/// <param name="table">The table name.</param>
	/// <returns>The fully qualified and escaped table name.</returns>
	protected static string Escape(string? schema, string table)
	{
		/*
		 * Handle schema qualification with proper escaping
		 */
		if (string.IsNullOrWhiteSpace(schema))
			return Escape(table);

		return $"{Escape(schema)}.{Escape(table)}";
	}

	/// <summary>
	/// Formats a PostgreSQL data type string with optional size parameters.
	/// </summary>
	/// <param name="dataType">The DbType to format.</param>
	/// <param name="size">The size parameter for the type, or 0 if not applicable.</param>
	/// <returns>The formatted type string (e.g., "VARCHAR(50)", "INTEGER").</returns>
	protected static string FormatType(DbType dataType, int size)
	{
		var pgType = MapDbTypeToPostgreSqlType(dataType);

		/*
		 * PostgreSQL TEXT type doesn't need size specification
		 */
		if (string.Equals(pgType, "text", StringComparison.OrdinalIgnoreCase))
			return pgType.ToUpper();

		if (size > 0 && RequiresLength(dataType))
			return $"{pgType.ToUpper()}({size})";

		return pgType.ToUpper();
	}

	/// <summary>
	/// Maps DbType to PostgreSQL type names.
	/// </summary>
	/// <param name="dbType">The DbType to map.</param>
	/// <returns>The PostgreSQL type name.</returns>
	private static string MapDbTypeToPostgreSqlType(DbType dbType)
	{
		return dbType switch
		{
			DbType.Int16 => "smallint",
			DbType.Int32 => "integer",
			DbType.Int64 => "bigint",
			DbType.Single => "real",
			DbType.Double => "double precision",
			DbType.Decimal => "numeric",
			DbType.Currency => "money",
			DbType.String => "varchar",
			DbType.StringFixedLength => "char",
			DbType.AnsiString => "varchar",
			DbType.AnsiStringFixedLength => "char",
			DbType.Binary => "bytea",
			DbType.Boolean => "boolean",
			DbType.Date => "date",
			DbType.DateTime => "timestamp",
			DbType.DateTime2 => "timestamp",
			DbType.DateTimeOffset => "timestamptz",
			DbType.Time => "time",
			DbType.Guid => "uuid",
			DbType.Xml => "xml",
			_ => "text"
		};
	}

	/// <summary>
	/// Determines if a DbType requires length specification.
	/// </summary>
	/// <param name="dbType">The DbType to check.</param>
	/// <returns><c>true</c> if length is required; otherwise, <c>false</c>.</returns>
	private static bool RequiresLength(DbType dbType)
	{
		return dbType is DbType.String or DbType.StringFixedLength or DbType.AnsiString or DbType.AnsiStringFixedLength or DbType.Binary;
	}

	/// <summary>
	/// Creates the column definition SQL for a schema column.
	/// </summary>
	/// <param name="column">The schema column to generate definition for.</param>
	/// <returns>The column definition SQL fragment.</returns>
	protected static string CreateColumnCommandText(ISchemaColumn column)
	{
		var text = new StringBuilder();

		text.Append(Escape(column.Name));
		text.Append(' ');
		text.Append(FormatType(column.DataType, column.MaxLength));

		/*
		 * Add IDENTITY specification for auto-increment columns
		 * PostgreSQL uses GENERATED BY DEFAULT AS IDENTITY
		 */
		if (column.IsIdentity)
			text.Append(" GENERATED BY DEFAULT AS IDENTITY");

		/*
		 * Add NULL/NOT NULL constraint
		 */
		if (column.IsNullable)
			text.Append(" NULL");
		else
			text.Append(" NOT NULL");

		return text.ToString();
	}

	/// <summary>
	/// Parses index definitions from schema column attributes.
	/// </summary>
	/// <param name="schema">The schema definition containing columns with index attributes.</param>
	/// <returns>A list of index descriptors extracted from column metadata.</returns>
	protected static List<IndexDescriptor> ParseIndexes(ISchema schema)
	{
		var result = new List<IndexDescriptor>();

		/*
		 * Iterate through columns and collect index definitions based on IsIndex flag
		 */
		foreach (var column in schema.Columns)
		{
			if (!column.IsIndex)
				continue;

			/*
			 * Use column's Index property or column name as the index name
			 */
			var indexName = string.IsNullOrWhiteSpace(column.Index) ? $"IX_{schema.Name}_{column.Name}" : column.Index;

			var existing = result.FirstOrDefault(f => string.Equals(f.Name, indexName, StringComparison.Ordinal));

			if (existing is not null)
			{
				/*
				 * Add column to existing composite index
				 */
				existing.Columns.Add(column);
			}
			else
			{
				/*
				 * Create new index descriptor
				 */
				result.Add(new IndexDescriptor
				{
					Name = indexName,
					Schema = schema.Schema,
					Table = schema.Name,
					Columns = [column],
					IsUnique = column.IsUnique
				});
			}
		}

		return result;
	}
}
