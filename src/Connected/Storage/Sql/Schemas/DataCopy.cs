using Connected.Storage.Schemas;
using System.Data;
using System.Text;

namespace Connected.Storage.Sql.Schemas;

/// <summary>
/// Copies data from an existing table to a temporary table during schema recreation.
/// </summary>
/// <remarks>
/// This transaction generates and executes an INSERT INTO SELECT statement to copy data
/// from the original table to a temporary table. It is used during table recreation operations
/// where the table structure must be dropped and recreated. The operation intelligently handles
/// data type conversions when column types have changed, ensuring data is properly converted
/// to match the new schema. Version (rowversion) columns are excluded from copying as they
/// are automatically managed by the database. Only columns that exist in both schemas are copied
/// to avoid data loss while accommodating schema changes.
/// </remarks>
internal class DataCopy(ExistingSchema existing, string temporaryName)
	: TableTransaction
{
	private ExistingSchema Existing { get; } = existing;

	/// <summary>
	/// Gets the name of the temporary table where data will be copied.
	/// </summary>
	public string TemporaryName { get; } = temporaryName;

	/// <inheritdoc/>
	protected override async Task OnExecute()
	{
		/*
		 * Execute the INSERT INTO SELECT statement to copy data from the original table
		 * to the temporary table.
		 */
		await Context.Execute(CommandText);
	}

	/// <summary>
	/// Gets the DDL command text for copying data.
	/// </summary>
	/// <value>
	/// The INSERT INTO SELECT statement with appropriate type conversions.
	/// </value>
	private string CommandText
	{
		get
		{
			var text = new StringBuilder();
			var columnSet = new StringBuilder();
			var sourceSet = new StringBuilder();
			var comma = string.Empty;

			/*
			 * Build the column list and source expressions, handling type conversions
			 * where necessary when column types have changed.
			 */
			foreach (var column in Context.Schema.Columns)
			{
				/*
				 * Skip version columns as they are auto-generated by the database.
				 */
				if (column.IsVersion)
					continue;

				/*
				 * Find the corresponding column in the existing schema.
				 */
				var existing = Existing.Columns.FirstOrDefault(f => string.Equals(column.Name, f.Name, StringComparison.OrdinalIgnoreCase));

				if (existing is null)
					continue;

				columnSet.Append($"{comma}{Escape(column.Name)}");

				/*
				 * Apply type conversion if the data type, precision, or scale has changed
				 * and the column type requires conversion.
				 */
				if (NeedsConversion(column) && (existing.DataType != column.DataType || existing.Precision != column.Precision || existing.Scale != column.Scale))
					sourceSet.Append($"{comma}CONVERT({ConversionString(column)},{Escape(column.Name)})");
				else
					sourceSet.Append($"{comma}{Escape(column.Name)}");

				comma = ",";
			}

			/*
			 * Generate the complete INSERT INTO SELECT statement with existence check.
			 */
			text.AppendLine($"IF EXISTS (SELECT * FROM {Escape(Existing.Schema, Existing.Name)})");
			text.AppendLine($"INSERT INTO {Escape(Context.Schema.Schema, TemporaryName)} ({columnSet.ToString()})");
			text.AppendLine($"SELECT {sourceSet.ToString()} FROM {Escape(Existing.Schema, Existing.Name)}");

			return text.ToString();
		}
	}

	/// <summary>
	/// Generates the SQL type conversion string for a column.
	/// </summary>
	/// <param name="column">The column to generate conversion string for.</param>
	/// <returns>The SQL type name with precision and scale if applicable.</returns>
	/// <exception cref="NotSupportedException">Thrown when the data type is not supported for conversion.</exception>
	private static string ConversionString(ISchemaColumn column)
	{
		return column.DataType switch
		{
			DbType.Byte => "tinyint",
			DbType.Currency => "money",
			DbType.Decimal => $"decimal({column.Precision}, {column.Scale})",
			DbType.Double => "real",
			DbType.Int16 => "smallint",
			DbType.Int32 => "int",
			DbType.Int64 => "bigint",
			DbType.SByte => "smallint",
			DbType.Single => "float",
			DbType.UInt16 => "int",
			DbType.UInt32 => "bigint",
			DbType.UInt64 => "float",
			DbType.VarNumeric => $"numeric({column.Precision}, {column.Scale})",
			_ => throw new NotSupportedException(),
		};
	}

	/// <summary>
	/// Determines whether a column type requires explicit conversion.
	/// </summary>
	/// <param name="column">The column to check.</param>
	/// <returns><c>true</c> if the column requires conversion; otherwise, <c>false</c>.</returns>
	/// <remarks>
	/// Numeric types generally require explicit conversion to handle precision and scale changes.
	/// </remarks>
	private static bool NeedsConversion(ISchemaColumn column)
	{
		return column.DataType switch
		{
			DbType.Byte or DbType.Currency or DbType.Decimal or DbType.Double or DbType.Int16 or DbType.Int32 or DbType.Int64 or DbType.SByte
			or DbType.Single or DbType.UInt16 or DbType.UInt32 or DbType.UInt64 or DbType.VarNumeric => true,
			_ => false,
		};
	}
}
